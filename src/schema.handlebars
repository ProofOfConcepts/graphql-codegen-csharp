using System;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Generated.Mutation.Models
{
  // inputTypes start 
  {{#each inputTypes}}
    {{~> classes }}
  {{/each}}

  // inputTypes end

  {{#each enums}}
    {{~> enum }}
  {{/each}}
}

namespace Generated.Mutation.Arguments
{
  using Generated.Mutation.Models;

  public interface IMutationArg
  {
    string GetMutationText();
    Dictionary<string, object> GetVariables();
  }

  {{~#each types}}
    {{~#each fields}}
      {{~# if hasArguments }}
        {{#if (isMutation this.name)}}
  
  public class {{ toPascalCase name }}Args : IMutationArg
  {
          {{#each arguments}}    
    {{ toCsharpComment description }}
    public {{ convertedType this }} {{ toPascalCase name }} { get; set; }     
          {{/each}}

    public string GetMutationText()
    {
      return "";
    }

    public Dictionary<string, object> GetVariables()
    {
      return new Dictionary<string, object>() {
        {{#each arguments}}
        { "{{name}}", {{ toPascalCase name }} },
        {{/each}}
      };
    }
  }
        {{/if}}
      {{/if}}
    {{/each}}
  {{/each}}
}

namespace Generated.Mutations 
{
  using Generated.Mutation.Arguments;

  public interface IMutation
  {
    string GetMutationText();
  } 

  public abstract class Mutation<T> where T : IMutationArg
  {    
    public Mutation(T args)
    {
      Args = args;
    }

    protected T Args { get; }

    public string GetMutationText()
    {
      return JsonConvert.SerializeObject(new
        {
            query = Args.GetMutationText(),
            variables = Args.GetVariables()
        });
    } 
  }

  {{#each types}}
    {{#if (eq name "Mutation")}}    
  {{ toCsharpComment "Mutation" }}      
      {{#each fields}}      
        {{#if (isMutation name)}}                     
  public class {{name}} : Mutation<{{name}}Args>
  {   
    public {{name}}({{name}}Args args) : base(args)
    {      
    }      
  }
        {{/if}}
      {{/each}}     
    {{/if}}
  {{/each}}
}



